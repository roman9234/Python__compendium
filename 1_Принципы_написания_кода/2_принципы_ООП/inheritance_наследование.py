# TODO переделать проект в хранилище синтаксиса python

# Класс, от которого наследуют, называется родительским или базовым
# Класс, который наследует другой класс, называют дочерним или производным
# Прямой суперкласс - родитель, косвенный суперкласс - выше суперкласса

# ---- Простой пример класса и объекта ----

class A:  # описание класса
    a = 3

    def __init__(self, a):  # конструктор класса
        self.a = a  # поля класса

class B(A):
    def __init__(self, a):
        # вызов конструктора суперкласса
        super().__init__(a)
        self.b = 2

# ---- Уровни наследования ведутся от более абстрактного к полее конкретному ----
# Например транспорт>машины>opel
# ! Класс Object - начало иерархии классов python
# ! python поддерживает множественное наследование



# ---- Порядок наследования ----
# ! порядок наследования определяет приоритет изменений
#  MRO - кортеж, называемый порядком разрешения методов
#  для MRO используется алгоритм поиска в глубину
# __mro__

# ! функция super принимает 2 аргумента - подкласс и экземпляр подкласса
# использование MRO по умолчанию может привести проблемы с множественным наследованием
# функция super позволяет определить порядок наследования
# пример: ставим приоритет init A над B
class A:
    def __init__(self):
        self.message = "Hello from A!"

class B1:
    def __init__(self):
        self.message = "Hello from B!"

class C(A, B1):
    def __init__(self):
        super().__init__()

c = C()
print(c.message)

# ! Другой способ - использовать атрибут bases
# bases это кортеж, содержащий базовые классы подкласса в том порядке,
# в котором они перечислены в определении класса
# можно изменить порядок bases чтобы изменить порядок наследования
# считается менее безопасным и менее удобным

C.__bases__ = (B1,A)
c2 = C()
print(c2.message)


# ---- Абстрактные методы и классы ----
# предназначены для использования как суперклассы для других классов
# позволяют определять абстрактные методы

# абстрактный метод - объявлен, но не реализован.
# Предоставляют возможность определить общий набор методов для группы родственных классов
# Ответственность за реализацию лежит на наследниках
# В отличие от  java здесь абстрактные классы могут иметь реализацию методов
# пример:

from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod #декоратор указывает что метод не имеет реализации
    def speak(self):
        pass

class Cat(Animal):
    def speak(self):
        return "Meow"

c = Cat()
print(c.speak())

