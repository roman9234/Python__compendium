# Замыкание
# Фкнция, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции

# позволяет функции получать доступ и управлять переменными во внешней области

# часто используется, когда функции нужно запомнить своё состояние между вызовами

# замыкание лучше использовать с функциями обратного вызова, которые передаются в качестве аргументов другим функциям
# создавая замыкание вокруг функции обратного вызова, мы гарантируем, что она имеет доступ к нужным ей переменным, даже если будет вызвана позже

# не стоит использовать замыкание в критическим важном для производительности коде


a = 4


def func1():
    return a + 1


def func2():
    b = 1
    return a + b


def func3():
    x = 1
    return lambda: a + x


# Пример: Логгирование с замыканием

def logger(func):
    def inner(*args, **kwargs):
        print(f"calling function {func.__name__}")
        result = func(*args, **kwargs)
        print(f"Finishing calling function {func.__name__}")
        return result

    return inner


@logger
def add(a, b):
    return a + b


print(add(3, 1))


# пример кэширование


# 1. Функция cache определяется как функция-декоратор, которая принимает в качестве аргумента другую функцию func.
# Она возвращает новую внутреннюю функцию, которая будет использоваться для декорирования исходной функции.
def cache(func):
    # 2. Словарь определен для хранения результатов исходной функции.
    results = {}

    # 3. Внутренняя функция принимает любое количество аргументов и использует синтаксис *args для записи их в виде кортежа.
    # Сначала она проверяет, была ли функция уже вызвана с заданными аргументами, выполняя поиск аргументов кортежа в словаре результатов.
    # Если кортеж найден, она возвращает кэшированный результат.
    # В противном случае она вызывает исходную функцию с заданными аргументами, сохраняет результат в словаре и возвращает результат.
    def inner(*args):
        if args in results:
            return results[args]
        result = func(*args)
        results[args] = result
        # 4. cache-функция возвращает внутреннюю функцию, которая используется для декорирования исходной функции.
        return result

    return inner


# 5. Функция fib определена и дополнена синтаксисом @cache, что означает, что декоратор обернет ее,
# а результаты вызова будут кэшированы.
@cache
def fib(n):
    if n <= 1:
        return n
    return fib(n - 1) + fib(n - 2)


print(fib(7))

# 6. Функция fib рекурсивно вычисляет последовательность Фибоначчи, используя формулу fib(_n) = fib(_n-1) + fib(_n-2), пока не достигнет базового случая _n <= 1. Эта реализация неэффективна, но она служит хорошим примером для демонстрации декоратора.
# 7. Функция fib вызывается с аргументом 5, который вычисляет 5-е число в последовательности Фибоначчи, а результат присваивается переменной result.
# 8. Наконец, результат вызова функции fib распечатывается. Поскольку используется декоратор с кешированием, результат извлекается из кеша и вычисления не повторяются.
